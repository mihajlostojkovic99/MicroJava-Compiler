!SESSION 2022-02-07 12:31:01.084 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\Test\Desktop\PP1\workspace\.metadata\.bak_0.log
Created Time: 2022-02-07 12:58:22.973

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-07 12:58:22.974
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-07 12:58:22.975
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-07 12:58:58.009
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rs.ac.bg.etf.pp1;
import org.apache.log4j.Logger;

import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.Obj;
import rs.etf.pp1.symboltable.concepts.Struct;

public class SemanticPass extends VisitorAdaptor {

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

	private Obj thisProgram;

	private Struct currentType;
	
	private Struct boolType = Tab.find("bool").getType();

	private boolean mainHappened = false;

	private Obj currMethod;

	private Struct currRecord;

	public void report_error(String message, SyntaxNode info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.error(msg.toString());
	}

	public void report_info(String message, SyntaxNode info) {
		StringBuilder msg = new StringBuilder(message); 
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.info(msg.toString());
	}
	
	@Override
	public void visit(ProgramName programName) {
		thisProgram = Tab.insert(Obj.Prog, programName.getI1(), Tab.noType);
		Tab.openScope();
	}
	
	@Override
	public void visit(Program program) {		
		Tab.chainLocalSymbols(thisProgram);
		Tab.closeScope();
		
		if (!mainHappened)
			report_error("void main() method is not defined", program);
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------- GLOBAL_CONST_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(ConstDeclBool constDeclBool) {
		Obj tmp = Tab.find(constDeclBool.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclBool.getI1() + "'", constDeclBool);
		}
		else {
			if (boolType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclBool.getI1(), currentType);
				tmp.setAdr(constDeclBool.getB2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclBool.getI1() + "'", constDeclBool);
			}
		}
	}
	
	@Override
	public void visit(ConstDeclChar constDeclChar) {
		Obj tmp = Tab.find(constDeclChar.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclChar.getI1() + "'", constDeclChar);
		}
		else {
			if (Tab.charType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclChar.getI1(), currentType);
				tmp.setAdr(constDeclChar.getC2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclChar.getI1() + "'", constDeclChar);
			}	
		}
	}
	
	@Override
	public void visit(ConstDeclNumber constDeclNumber) {
		Obj tmp = Tab.find(constDeclNumber.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclNumber.getI1() + "'", constDeclNumber);
		}
		else {
			if (Tab.intType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclNumber.getI1(), currentType);
				tmp.setAdr(constDeclNumber.getN2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclNumber.getI1() + "'", constDeclNumber);
			}
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ------------------------------------------------------------------- GLOBAL_VAR_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(NormalVarDecl normalVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(normalVarDecl.getI1());
		
		(currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1())
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, normalVarDecl.getI1(), currentType);
		}
		else {
			report_error("Multiple definitions of variable '" + normalVarDecl.getI1() + "'", normalVarDecl);
		}
	}
	
	@Override
	public void visit(ArrayVarDecl arrayVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(arrayVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(arrayVarDecl.getI1());
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(currRecord == null ? Obj.Var : Obj.Fld, arrayVarDecl.getI1(), new Struct(Struct.Array, currentType));
			if (currRecord != null) tmp.setLevel(2);
		}
		else {
			report_error("Multiple definitions of variable '" + arrayVarDecl.getI1() + "'", arrayVarDecl);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- METHOD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(MethodName methodName) {
		if (methodName.getI1().equalsIgnoreCase("main") && currentType == Tab.noType) mainHappened  = true;
		currMethod = Tab.insert(Obj.Meth, methodName.getI1(), currentType);
		Tab.openScope();
	}
	
	@Override
	public void visit(MethodRetVoid methodRetVoid) {
		currentType = Tab.noType;
	}
	
	@Override
	public void visit(MethDeclParams methDeclParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(MethDeclNoParams methDeclNoParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(FormalParameter formalParameter) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameter);
		else tmp = Tab.currentScope().findSymbol(formalParameter.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main") && currMethod.getType() == Tab.noType) 
			report_error("Formal parameters in void main() are forbidden", formalParameter);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameter.getI2(), currentType);
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of formal parameter '" + formalParameter.getI2() + "'", formalParameter);
		}
	}
	
	@Override
	public void visit(FormalParameterArray formalParameterArray) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameterArray);
		else tmp = Tab.currentScope().findSymbol(formalParameterArray.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main")) report_error("Formal parameters in void main() are forbidden", formalParameterArray);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameterArray.getI2(), new Struct(Struct.Array, currentType));
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of variable '" + formalParameterArray.getI2() + "'", formalParameterArray);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- RECORD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(RecordDeclName recordDeclName) {
		Obj tmp = Tab.find(recordDeclName.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of record '" + recordDeclName.getI1() + "'", recordDeclName);
		}
		else {
			currRecord = new Struct(Struct.Class);
			tmp = Tab.insert(Obj.Type, recordDeclName.getI1(), currRecord);
			Tab.openScope();
		}
	}
	
	@Override
	public void visit(RecordDecl recordDecl) {
		Tab.chainLocalSymbols(currRecord);
		Tab.closeScope();
		currRecord = null;
	}
	
	@Override
	public void visit(Type type) {
		Obj typeObj = Tab.find(type.getI1());
		if (typeObj == Tab.noObj) {
			report_error("Type '" + type.getI1() + "' is not defined", type);
			currentType = Tab.noType;
			return;
		}
		
		if (typeObj.getKind() != Obj.Type) {
			report_error("Unallowed type '" + type.getI1() + "'", type);
			return;
		}
		
		currentType = typeObj.getType();
	}
	
	public boolean passed() {
		return !errorDetected;
	}
	
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-07 12:58:58.010
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-07 12:58:58.010
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-07 12:58:58.052
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rs.ac.bg.etf.pp1;
import org.apache.log4j.Logger;

import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.Obj;
import rs.etf.pp1.symboltable.concepts.Struct;

public class SemanticPass extends VisitorAdaptor {

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

	private Obj thisProgram;

	private Struct currentType;
	
	private Struct boolType = Tab.find("bool").getType();

	private boolean mainHappened = false;

	private Obj currMethod;

	private Struct currRecord;

	public void report_error(String message, SyntaxNode info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.error(msg.toString());
	}

	public void report_info(String message, SyntaxNode info) {
		StringBuilder msg = new StringBuilder(message); 
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.info(msg.toString());
	}
	
	@Override
	public void visit(ProgramName programName) {
		thisProgram = Tab.insert(Obj.Prog, programName.getI1(), Tab.noType);
		Tab.openScope();
	}
	
	@Override
	public void visit(Program program) {		
		Tab.chainLocalSymbols(thisProgram);
		Tab.closeScope();
		
		if (!mainHappened)
			report_error("void main() method is not defined", program);
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------- GLOBAL_CONST_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(ConstDeclBool constDeclBool) {
		Obj tmp = Tab.find(constDeclBool.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclBool.getI1() + "'", constDeclBool);
		}
		else {
			if (boolType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclBool.getI1(), currentType);
				tmp.setAdr(constDeclBool.getB2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclBool.getI1() + "'", constDeclBool);
			}
		}
	}
	
	@Override
	public void visit(ConstDeclChar constDeclChar) {
		Obj tmp = Tab.find(constDeclChar.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclChar.getI1() + "'", constDeclChar);
		}
		else {
			if (Tab.charType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclChar.getI1(), currentType);
				tmp.setAdr(constDeclChar.getC2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclChar.getI1() + "'", constDeclChar);
			}	
		}
	}
	
	@Override
	public void visit(ConstDeclNumber constDeclNumber) {
		Obj tmp = Tab.find(constDeclNumber.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclNumber.getI1() + "'", constDeclNumber);
		}
		else {
			if (Tab.intType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclNumber.getI1(), currentType);
				tmp.setAdr(constDeclNumber.getN2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclNumber.getI1() + "'", constDeclNumber);
			}
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ------------------------------------------------------------------- GLOBAL_VAR_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(NormalVarDecl normalVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(normalVarDecl.getI1());
		
		(currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1())
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, normalVarDecl.getI1(), currentType);
		}
		else {
			report_error("Multiple definitions of variable '" + normalVarDecl.getI1() + "'", normalVarDecl);
		}
	}
	
	@Override
	public void visit(ArrayVarDecl arrayVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(arrayVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(arrayVarDecl.getI1());
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(currRecord == null ? Obj.Var : Obj.Fld, arrayVarDecl.getI1(), new Struct(Struct.Array, currentType));
			if (currRecord != null) tmp.setLevel(2);
		}
		else {
			report_error("Multiple definitions of variable '" + arrayVarDecl.getI1() + "'", arrayVarDecl);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- METHOD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(MethodName methodName) {
		if (methodName.getI1().equalsIgnoreCase("main") && currentType == Tab.noType) mainHappened  = true;
		currMethod = Tab.insert(Obj.Meth, methodName.getI1(), currentType);
		Tab.openScope();
	}
	
	@Override
	public void visit(MethodRetVoid methodRetVoid) {
		currentType = Tab.noType;
	}
	
	@Override
	public void visit(MethDeclParams methDeclParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(MethDeclNoParams methDeclNoParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(FormalParameter formalParameter) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameter);
		else tmp = Tab.currentScope().findSymbol(formalParameter.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main") && currMethod.getType() == Tab.noType) 
			report_error("Formal parameters in void main() are forbidden", formalParameter);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameter.getI2(), currentType);
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of formal parameter '" + formalParameter.getI2() + "'", formalParameter);
		}
	}
	
	@Override
	public void visit(FormalParameterArray formalParameterArray) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameterArray);
		else tmp = Tab.currentScope().findSymbol(formalParameterArray.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main")) report_error("Formal parameters in void main() are forbidden", formalParameterArray);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameterArray.getI2(), new Struct(Struct.Array, currentType));
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of variable '" + formalParameterArray.getI2() + "'", formalParameterArray);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- RECORD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(RecordDeclName recordDeclName) {
		Obj tmp = Tab.find(recordDeclName.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of record '" + recordDeclName.getI1() + "'", recordDeclName);
		}
		else {
			currRecord = new Struct(Struct.Class);
			tmp = Tab.insert(Obj.Type, recordDeclName.getI1(), currRecord);
			Tab.openScope();
		}
	}
	
	@Override
	public void visit(RecordDecl recordDecl) {
		Tab.chainLocalSymbols(currRecord);
		Tab.closeScope();
		currRecord = null;
	}
	
	@Override
	public void visit(Type type) {
		Obj typeObj = Tab.find(type.getI1());
		if (typeObj == Tab.noObj) {
			report_error("Type '" + type.getI1() + "' is not defined", type);
			currentType = Tab.noType;
			return;
		}
		
		if (typeObj.getKind() != Obj.Type) {
			report_error("Unallowed type '" + type.getI1() + "'", type);
			return;
		}
		
		currentType = typeObj.getType();
	}
	
	public boolean passed() {
		return !errorDetected;
	}
	
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-07 12:58:58.053
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-07 12:58:58.054
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-07 12:59:00.318
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rs.ac.bg.etf.pp1;
import org.apache.log4j.Logger;

import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.Obj;
import rs.etf.pp1.symboltable.concepts.Struct;

public class SemanticPass extends VisitorAdaptor {

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

	private Obj thisProgram;

	private Struct currentType;
	
	private Struct boolType = Tab.find("bool").getType();

	private boolean mainHappened = false;

	private Obj currMethod;

	private Struct currRecord;

	public void report_error(String message, SyntaxNode info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.error(msg.toString());
	}

	public void report_info(String message, SyntaxNode info) {
		StringBuilder msg = new StringBuilder(message); 
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.info(msg.toString());
	}
	
	@Override
	public void visit(ProgramName programName) {
		thisProgram = Tab.insert(Obj.Prog, programName.getI1(), Tab.noType);
		Tab.openScope();
	}
	
	@Override
	public void visit(Program program) {		
		Tab.chainLocalSymbols(thisProgram);
		Tab.closeScope();
		
		if (!mainHappened)
			report_error("void main() method is not defined", program);
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------- GLOBAL_CONST_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(ConstDeclBool constDeclBool) {
		Obj tmp = Tab.find(constDeclBool.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclBool.getI1() + "'", constDeclBool);
		}
		else {
			if (boolType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclBool.getI1(), currentType);
				tmp.setAdr(constDeclBool.getB2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclBool.getI1() + "'", constDeclBool);
			}
		}
	}
	
	@Override
	public void visit(ConstDeclChar constDeclChar) {
		Obj tmp = Tab.find(constDeclChar.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclChar.getI1() + "'", constDeclChar);
		}
		else {
			if (Tab.charType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclChar.getI1(), currentType);
				tmp.setAdr(constDeclChar.getC2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclChar.getI1() + "'", constDeclChar);
			}	
		}
	}
	
	@Override
	public void visit(ConstDeclNumber constDeclNumber) {
		Obj tmp = Tab.find(constDeclNumber.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclNumber.getI1() + "'", constDeclNumber);
		}
		else {
			if (Tab.intType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclNumber.getI1(), currentType);
				tmp.setAdr(constDeclNumber.getN2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclNumber.getI1() + "'", constDeclNumber);
			}
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ------------------------------------------------------------------- GLOBAL_VAR_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(NormalVarDecl normalVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(normalVarDecl.getI1());
		
		(currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1())
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, normalVarDecl.getI1(), currentType);
		}
		else {
			report_error("Multiple definitions of variable '" + normalVarDecl.getI1() + "'", normalVarDecl);
		}
	}
	
	@Override
	public void visit(ArrayVarDecl arrayVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(arrayVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(arrayVarDecl.getI1());
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(currRecord == null ? Obj.Var : Obj.Fld, arrayVarDecl.getI1(), new Struct(Struct.Array, currentType));
			if (currRecord != null) tmp.setLevel(2);
		}
		else {
			report_error("Multiple definitions of variable '" + arrayVarDecl.getI1() + "'", arrayVarDecl);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- METHOD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(MethodName methodName) {
		if (methodName.getI1().equalsIgnoreCase("main") && currentType == Tab.noType) mainHappened  = true;
		currMethod = Tab.insert(Obj.Meth, methodName.getI1(), currentType);
		Tab.openScope();
	}
	
	@Override
	public void visit(MethodRetVoid methodRetVoid) {
		currentType = Tab.noType;
	}
	
	@Override
	public void visit(MethDeclParams methDeclParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(MethDeclNoParams methDeclNoParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(FormalParameter formalParameter) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameter);
		else tmp = Tab.currentScope().findSymbol(formalParameter.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main") && currMethod.getType() == Tab.noType) 
			report_error("Formal parameters in void main() are forbidden", formalParameter);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameter.getI2(), currentType);
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of formal parameter '" + formalParameter.getI2() + "'", formalParameter);
		}
	}
	
	@Override
	public void visit(FormalParameterArray formalParameterArray) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameterArray);
		else tmp = Tab.currentScope().findSymbol(formalParameterArray.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main")) report_error("Formal parameters in void main() are forbidden", formalParameterArray);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameterArray.getI2(), new Struct(Struct.Array, currentType));
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of variable '" + formalParameterArray.getI2() + "'", formalParameterArray);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- RECORD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(RecordDeclName recordDeclName) {
		Obj tmp = Tab.find(recordDeclName.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of record '" + recordDeclName.getI1() + "'", recordDeclName);
		}
		else {
			currRecord = new Struct(Struct.Class);
			tmp = Tab.insert(Obj.Type, recordDeclName.getI1(), currRecord);
			Tab.openScope();
		}
	}
	
	@Override
	public void visit(RecordDecl recordDecl) {
		Tab.chainLocalSymbols(currRecord);
		Tab.closeScope();
		currRecord = null;
	}
	
	@Override
	public void visit(Type type) {
		Obj typeObj = Tab.find(type.getI1());
		if (typeObj == Tab.noObj) {
			report_error("Type '" + type.getI1() + "' is not defined", type);
			currentType = Tab.noType;
			return;
		}
		
		if (typeObj.getKind() != Obj.Type) {
			report_error("Unallowed type '" + type.getI1() + "'", type);
			return;
		}
		
		currentType = typeObj.getType();
	}
	
	public boolean passed() {
		return !errorDetected;
	}
	
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-07 12:59:00.319
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-07 12:59:00.320
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-07 12:59:00.411
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rs.ac.bg.etf.pp1;
import org.apache.log4j.Logger;

import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.Obj;
import rs.etf.pp1.symboltable.concepts.Struct;

public class SemanticPass extends VisitorAdaptor {

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

	private Obj thisProgram;

	private Struct currentType;
	
	private Struct boolType = Tab.find("bool").getType();

	private boolean mainHappened = false;

	private Obj currMethod;

	private Struct currRecord;

	public void report_error(String message, SyntaxNode info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.error(msg.toString());
	}

	public void report_info(String message, SyntaxNode info) {
		StringBuilder msg = new StringBuilder(message); 
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.info(msg.toString());
	}
	
	@Override
	public void visit(ProgramName programName) {
		thisProgram = Tab.insert(Obj.Prog, programName.getI1(), Tab.noType);
		Tab.openScope();
	}
	
	@Override
	public void visit(Program program) {		
		Tab.chainLocalSymbols(thisProgram);
		Tab.closeScope();
		
		if (!mainHappened)
			report_error("void main() method is not defined", program);
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------- GLOBAL_CONST_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(ConstDeclBool constDeclBool) {
		Obj tmp = Tab.find(constDeclBool.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclBool.getI1() + "'", constDeclBool);
		}
		else {
			if (boolType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclBool.getI1(), currentType);
				tmp.setAdr(constDeclBool.getB2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclBool.getI1() + "'", constDeclBool);
			}
		}
	}
	
	@Override
	public void visit(ConstDeclChar constDeclChar) {
		Obj tmp = Tab.find(constDeclChar.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclChar.getI1() + "'", constDeclChar);
		}
		else {
			if (Tab.charType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclChar.getI1(), currentType);
				tmp.setAdr(constDeclChar.getC2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclChar.getI1() + "'", constDeclChar);
			}	
		}
	}
	
	@Override
	public void visit(ConstDeclNumber constDeclNumber) {
		Obj tmp = Tab.find(constDeclNumber.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclNumber.getI1() + "'", constDeclNumber);
		}
		else {
			if (Tab.intType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclNumber.getI1(), currentType);
				tmp.setAdr(constDeclNumber.getN2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclNumber.getI1() + "'", constDeclNumber);
			}
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ------------------------------------------------------------------- GLOBAL_VAR_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(NormalVarDecl normalVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(normalVarDecl.getI1());
		
		(currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1())
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, normalVarDecl.getI1(), currentType);
		}
		else {
			report_error("Multiple definitions of variable '" + normalVarDecl.getI1() + "'", normalVarDecl);
		}
	}
	
	@Override
	public void visit(ArrayVarDecl arrayVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(arrayVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(arrayVarDecl.getI1());
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(currRecord == null ? Obj.Var : Obj.Fld, arrayVarDecl.getI1(), new Struct(Struct.Array, currentType));
			if (currRecord != null) tmp.setLevel(2);
		}
		else {
			report_error("Multiple definitions of variable '" + arrayVarDecl.getI1() + "'", arrayVarDecl);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- METHOD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(MethodName methodName) {
		if (methodName.getI1().equalsIgnoreCase("main") && currentType == Tab.noType) mainHappened  = true;
		currMethod = Tab.insert(Obj.Meth, methodName.getI1(), currentType);
		Tab.openScope();
	}
	
	@Override
	public void visit(MethodRetVoid methodRetVoid) {
		currentType = Tab.noType;
	}
	
	@Override
	public void visit(MethDeclParams methDeclParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(MethDeclNoParams methDeclNoParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(FormalParameter formalParameter) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameter);
		else tmp = Tab.currentScope().findSymbol(formalParameter.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main") && currMethod.getType() == Tab.noType) 
			report_error("Formal parameters in void main() are forbidden", formalParameter);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameter.getI2(), currentType);
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of formal parameter '" + formalParameter.getI2() + "'", formalParameter);
		}
	}
	
	@Override
	public void visit(FormalParameterArray formalParameterArray) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameterArray);
		else tmp = Tab.currentScope().findSymbol(formalParameterArray.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main")) report_error("Formal parameters in void main() are forbidden", formalParameterArray);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameterArray.getI2(), new Struct(Struct.Array, currentType));
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of variable '" + formalParameterArray.getI2() + "'", formalParameterArray);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- RECORD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(RecordDeclName recordDeclName) {
		Obj tmp = Tab.find(recordDeclName.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of record '" + recordDeclName.getI1() + "'", recordDeclName);
		}
		else {
			currRecord = new Struct(Struct.Class);
			tmp = Tab.insert(Obj.Type, recordDeclName.getI1(), currRecord);
			Tab.openScope();
		}
	}
	
	@Override
	public void visit(RecordDecl recordDecl) {
		Tab.chainLocalSymbols(currRecord);
		Tab.closeScope();
		currRecord = null;
	}
	
	@Override
	public void visit(Type type) {
		Obj typeObj = Tab.find(type.getI1());
		if (typeObj == Tab.noObj) {
			report_error("Type '" + type.getI1() + "' is not defined", type);
			currentType = Tab.noType;
			return;
		}
		
		if (typeObj.getKind() != Obj.Type) {
			report_error("Unallowed type '" + type.getI1() + "'", type);
			return;
		}
		
		currentType = typeObj.getType();
	}
	
	public boolean passed() {
		return !errorDetected;
	}
	
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-07 12:59:00.411
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-07 12:59:00.412
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-07 12:59:00.454
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rs.ac.bg.etf.pp1;
import org.apache.log4j.Logger;

import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.Obj;
import rs.etf.pp1.symboltable.concepts.Struct;

public class SemanticPass extends VisitorAdaptor {

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

	private Obj thisProgram;

	private Struct currentType;
	
	private Struct boolType = Tab.find("bool").getType();

	private boolean mainHappened = false;

	private Obj currMethod;

	private Struct currRecord;

	public void report_error(String message, SyntaxNode info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.error(msg.toString());
	}

	public void report_info(String message, SyntaxNode info) {
		StringBuilder msg = new StringBuilder(message); 
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.info(msg.toString());
	}
	
	@Override
	public void visit(ProgramName programName) {
		thisProgram = Tab.insert(Obj.Prog, programName.getI1(), Tab.noType);
		Tab.openScope();
	}
	
	@Override
	public void visit(Program program) {		
		Tab.chainLocalSymbols(thisProgram);
		Tab.closeScope();
		
		if (!mainHappened)
			report_error("void main() method is not defined", program);
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------- GLOBAL_CONST_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(ConstDeclBool constDeclBool) {
		Obj tmp = Tab.find(constDeclBool.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclBool.getI1() + "'", constDeclBool);
		}
		else {
			if (boolType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclBool.getI1(), currentType);
				tmp.setAdr(constDeclBool.getB2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclBool.getI1() + "'", constDeclBool);
			}
		}
	}
	
	@Override
	public void visit(ConstDeclChar constDeclChar) {
		Obj tmp = Tab.find(constDeclChar.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclChar.getI1() + "'", constDeclChar);
		}
		else {
			if (Tab.charType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclChar.getI1(), currentType);
				tmp.setAdr(constDeclChar.getC2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclChar.getI1() + "'", constDeclChar);
			}	
		}
	}
	
	@Override
	public void visit(ConstDeclNumber constDeclNumber) {
		Obj tmp = Tab.find(constDeclNumber.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclNumber.getI1() + "'", constDeclNumber);
		}
		else {
			if (Tab.intType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclNumber.getI1(), currentType);
				tmp.setAdr(constDeclNumber.getN2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclNumber.getI1() + "'", constDeclNumber);
			}
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ------------------------------------------------------------------- GLOBAL_VAR_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(NormalVarDecl normalVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(normalVarDecl.getI1());
		
		(currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1())
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, normalVarDecl.getI1(), currentType);
		}
		else {
			report_error("Multiple definitions of variable '" + normalVarDecl.getI1() + "'", normalVarDecl);
		}
	}
	
	@Override
	public void visit(ArrayVarDecl arrayVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(arrayVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(arrayVarDecl.getI1());
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(currRecord == null ? Obj.Var : Obj.Fld, arrayVarDecl.getI1(), new Struct(Struct.Array, currentType));
			if (currRecord != null) tmp.setLevel(2);
		}
		else {
			report_error("Multiple definitions of variable '" + arrayVarDecl.getI1() + "'", arrayVarDecl);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- METHOD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(MethodName methodName) {
		if (methodName.getI1().equalsIgnoreCase("main") && currentType == Tab.noType) mainHappened  = true;
		currMethod = Tab.insert(Obj.Meth, methodName.getI1(), currentType);
		Tab.openScope();
	}
	
	@Override
	public void visit(MethodRetVoid methodRetVoid) {
		currentType = Tab.noType;
	}
	
	@Override
	public void visit(MethDeclParams methDeclParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(MethDeclNoParams methDeclNoParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(FormalParameter formalParameter) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameter);
		else tmp = Tab.currentScope().findSymbol(formalParameter.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main") && currMethod.getType() == Tab.noType) 
			report_error("Formal parameters in void main() are forbidden", formalParameter);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameter.getI2(), currentType);
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of formal parameter '" + formalParameter.getI2() + "'", formalParameter);
		}
	}
	
	@Override
	public void visit(FormalParameterArray formalParameterArray) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameterArray);
		else tmp = Tab.currentScope().findSymbol(formalParameterArray.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main")) report_error("Formal parameters in void main() are forbidden", formalParameterArray);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameterArray.getI2(), new Struct(Struct.Array, currentType));
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of variable '" + formalParameterArray.getI2() + "'", formalParameterArray);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- RECORD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(RecordDeclName recordDeclName) {
		Obj tmp = Tab.find(recordDeclName.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of record '" + recordDeclName.getI1() + "'", recordDeclName);
		}
		else {
			currRecord = new Struct(Struct.Class);
			tmp = Tab.insert(Obj.Type, recordDeclName.getI1(), currRecord);
			Tab.openScope();
		}
	}
	
	@Override
	public void visit(RecordDecl recordDecl) {
		Tab.chainLocalSymbols(currRecord);
		Tab.closeScope();
		currRecord = null;
	}
	
	@Override
	public void visit(Type type) {
		Obj typeObj = Tab.find(type.getI1());
		if (typeObj == Tab.noObj) {
			report_error("Type '" + type.getI1() + "' is not defined", type);
			currentType = Tab.noType;
			return;
		}
		
		if (typeObj.getKind() != Obj.Type) {
			report_error("Unallowed type '" + type.getI1() + "'", type);
			return;
		}
		
		currentType = typeObj.getType();
	}
	
	public boolean passed() {
		return !errorDetected;
	}
	
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-07 12:59:00.455
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-07 12:59:00.456
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-07 12:59:01.529
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rs.ac.bg.etf.pp1;
import org.apache.log4j.Logger;

import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.Obj;
import rs.etf.pp1.symboltable.concepts.Struct;

public class SemanticPass extends VisitorAdaptor {

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

	private Obj thisProgram;

	private Struct currentType;
	
	private Struct boolType = Tab.find("bool").getType();

	private boolean mainHappened = false;

	private Obj currMethod;

	private Struct currRecord;

	public void report_error(String message, SyntaxNode info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.error(msg.toString());
	}

	public void report_info(String message, SyntaxNode info) {
		StringBuilder msg = new StringBuilder(message); 
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.info(msg.toString());
	}
	
	@Override
	public void visit(ProgramName programName) {
		thisProgram = Tab.insert(Obj.Prog, programName.getI1(), Tab.noType);
		Tab.openScope();
	}
	
	@Override
	public void visit(Program program) {		
		Tab.chainLocalSymbols(thisProgram);
		Tab.closeScope();
		
		if (!mainHappened)
			report_error("void main() method is not defined", program);
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------- GLOBAL_CONST_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(ConstDeclBool constDeclBool) {
		Obj tmp = Tab.find(constDeclBool.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclBool.getI1() + "'", constDeclBool);
		}
		else {
			if (boolType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclBool.getI1(), currentType);
				tmp.setAdr(constDeclBool.getB2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclBool.getI1() + "'", constDeclBool);
			}
		}
	}
	
	@Override
	public void visit(ConstDeclChar constDeclChar) {
		Obj tmp = Tab.find(constDeclChar.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclChar.getI1() + "'", constDeclChar);
		}
		else {
			if (Tab.charType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclChar.getI1(), currentType);
				tmp.setAdr(constDeclChar.getC2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclChar.getI1() + "'", constDeclChar);
			}	
		}
	}
	
	@Override
	public void visit(ConstDeclNumber constDeclNumber) {
		Obj tmp = Tab.find(constDeclNumber.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclNumber.getI1() + "'", constDeclNumber);
		}
		else {
			if (Tab.intType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclNumber.getI1(), currentType);
				tmp.setAdr(constDeclNumber.getN2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclNumber.getI1() + "'", constDeclNumber);
			}
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ------------------------------------------------------------------- GLOBAL_VAR_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(NormalVarDecl normalVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(normalVarDecl.getI1());
		
		(currMethod == null && currRecord == null) ? tmp = Tab.find(normalVarDecl.getI1())
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, normalVarDecl.getI1(), currentType);
		}
		else {
			report_error("Multiple definitions of variable '" + normalVarDecl.getI1() + "'", normalVarDecl);
		}
	}
	
	@Override
	public void visit(ArrayVarDecl arrayVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(arrayVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(arrayVarDecl.getI1());
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(currRecord == null ? Obj.Var : Obj.Fld, arrayVarDecl.getI1(), new Struct(Struct.Array, currentType));
			if (currRecord != null) tmp.setLevel(2);
		}
		else {
			report_error("Multiple definitions of variable '" + arrayVarDecl.getI1() + "'", arrayVarDecl);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- METHOD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(MethodName methodName) {
		if (methodName.getI1().equalsIgnoreCase("main") && currentType == Tab.noType) mainHappened  = true;
		currMethod = Tab.insert(Obj.Meth, methodName.getI1(), currentType);
		Tab.openScope();
	}
	
	@Override
	public void visit(MethodRetVoid methodRetVoid) {
		currentType = Tab.noType;
	}
	
	@Override
	public void visit(MethDeclParams methDeclParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(MethDeclNoParams methDeclNoParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(FormalParameter formalParameter) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameter);
		else tmp = Tab.currentScope().findSymbol(formalParameter.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main") && currMethod.getType() == Tab.noType) 
			report_error("Formal parameters in void main() are forbidden", formalParameter);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameter.getI2(), currentType);
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of formal parameter '" + formalParameter.getI2() + "'", formalParameter);
		}
	}
	
	@Override
	public void visit(FormalParameterArray formalParameterArray) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameterArray);
		else tmp = Tab.currentScope().findSymbol(formalParameterArray.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main")) report_error("Formal parameters in void main() are forbidden", formalParameterArray);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameterArray.getI2(), new Struct(Struct.Array, currentType));
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of variable '" + formalParameterArray.getI2() + "'", formalParameterArray);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- RECORD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(RecordDeclName recordDeclName) {
		Obj tmp = Tab.find(recordDeclName.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of record '" + recordDeclName.getI1() + "'", recordDeclName);
		}
		else {
			currRecord = new Struct(Struct.Class);
			tmp = Tab.insert(Obj.Type, recordDeclName.getI1(), currRecord);
			Tab.openScope();
		}
	}
	
	@Override
	public void visit(RecordDecl recordDecl) {
		Tab.chainLocalSymbols(currRecord);
		Tab.closeScope();
		currRecord = null;
	}
	
	@Override
	public void visit(Type type) {
		Obj typeObj = Tab.find(type.getI1());
		if (typeObj == Tab.noObj) {
			report_error("Type '" + type.getI1() + "' is not defined", type);
			currentType = Tab.noType;
			return;
		}
		
		if (typeObj.getKind() != Obj.Type) {
			report_error("Unallowed type '" + type.getI1() + "'", type);
			return;
		}
		
		currentType = typeObj.getType();
	}
	
	public boolean passed() {
		return !errorDetected;
	}
	
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-07 12:59:01.530
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-07 12:59:01.531
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-07 12:59:01.571
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rs.ac.bg.etf.pp1;
import org.apache.log4j.Logger;

import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.Obj;
import rs.etf.pp1.symboltable.concepts.Struct;

public class SemanticPass extends VisitorAdaptor {

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

	private Obj thisProgram;

	private Struct currentType;
	
	private Struct boolType = Tab.find("bool").getType();

	private boolean mainHappened = false;

	private Obj currMethod;

	private Struct currRecord;

	public void report_error(String message, SyntaxNode info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.error(msg.toString());
	}

	public void report_info(String message, SyntaxNode info) {
		StringBuilder msg = new StringBuilder(message); 
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.info(msg.toString());
	}
	
	@Override
	public void visit(ProgramName programName) {
		thisProgram = Tab.insert(Obj.Prog, programName.getI1(), Tab.noType);
		Tab.openScope();
	}
	
	@Override
	public void visit(Program program) {		
		Tab.chainLocalSymbols(thisProgram);
		Tab.closeScope();
		
		if (!mainHappened)
			report_error("void main() method is not defined", program);
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------- GLOBAL_CONST_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(ConstDeclBool constDeclBool) {
		Obj tmp = Tab.find(constDeclBool.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclBool.getI1() + "'", constDeclBool);
		}
		else {
			if (boolType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclBool.getI1(), currentType);
				tmp.setAdr(constDeclBool.getB2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclBool.getI1() + "'", constDeclBool);
			}
		}
	}
	
	@Override
	public void visit(ConstDeclChar constDeclChar) {
		Obj tmp = Tab.find(constDeclChar.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclChar.getI1() + "'", constDeclChar);
		}
		else {
			if (Tab.charType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclChar.getI1(), currentType);
				tmp.setAdr(constDeclChar.getC2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclChar.getI1() + "'", constDeclChar);
			}	
		}
	}
	
	@Override
	public void visit(ConstDeclNumber constDeclNumber) {
		Obj tmp = Tab.find(constDeclNumber.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclNumber.getI1() + "'", constDeclNumber);
		}
		else {
			if (Tab.intType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclNumber.getI1(), currentType);
				tmp.setAdr(constDeclNumber.getN2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclNumber.getI1() + "'", constDeclNumber);
			}
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ------------------------------------------------------------------- GLOBAL_VAR_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(NormalVarDecl normalVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(normalVarDecl.getI1());
		
		(currMethod == null && currRecord == null) ? tmp = Tab.find(normalVarDecl.getI1())
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, normalVarDecl.getI1(), currentType);
		}
		else {
			report_error("Multiple definitions of variable '" + normalVarDecl.getI1() + "'", normalVarDecl);
		}
	}
	
	@Override
	public void visit(ArrayVarDecl arrayVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(arrayVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(arrayVarDecl.getI1());
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(currRecord == null ? Obj.Var : Obj.Fld, arrayVarDecl.getI1(), new Struct(Struct.Array, currentType));
			if (currRecord != null) tmp.setLevel(2);
		}
		else {
			report_error("Multiple definitions of variable '" + arrayVarDecl.getI1() + "'", arrayVarDecl);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- METHOD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(MethodName methodName) {
		if (methodName.getI1().equalsIgnoreCase("main") && currentType == Tab.noType) mainHappened  = true;
		currMethod = Tab.insert(Obj.Meth, methodName.getI1(), currentType);
		Tab.openScope();
	}
	
	@Override
	public void visit(MethodRetVoid methodRetVoid) {
		currentType = Tab.noType;
	}
	
	@Override
	public void visit(MethDeclParams methDeclParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(MethDeclNoParams methDeclNoParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(FormalParameter formalParameter) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameter);
		else tmp = Tab.currentScope().findSymbol(formalParameter.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main") && currMethod.getType() == Tab.noType) 
			report_error("Formal parameters in void main() are forbidden", formalParameter);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameter.getI2(), currentType);
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of formal parameter '" + formalParameter.getI2() + "'", formalParameter);
		}
	}
	
	@Override
	public void visit(FormalParameterArray formalParameterArray) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameterArray);
		else tmp = Tab.currentScope().findSymbol(formalParameterArray.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main")) report_error("Formal parameters in void main() are forbidden", formalParameterArray);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameterArray.getI2(), new Struct(Struct.Array, currentType));
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of variable '" + formalParameterArray.getI2() + "'", formalParameterArray);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- RECORD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(RecordDeclName recordDeclName) {
		Obj tmp = Tab.find(recordDeclName.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of record '" + recordDeclName.getI1() + "'", recordDeclName);
		}
		else {
			currRecord = new Struct(Struct.Class);
			tmp = Tab.insert(Obj.Type, recordDeclName.getI1(), currRecord);
			Tab.openScope();
		}
	}
	
	@Override
	public void visit(RecordDecl recordDecl) {
		Tab.chainLocalSymbols(currRecord);
		Tab.closeScope();
		currRecord = null;
	}
	
	@Override
	public void visit(Type type) {
		Obj typeObj = Tab.find(type.getI1());
		if (typeObj == Tab.noObj) {
			report_error("Type '" + type.getI1() + "' is not defined", type);
			currentType = Tab.noType;
			return;
		}
		
		if (typeObj.getKind() != Obj.Type) {
			report_error("Unallowed type '" + type.getI1() + "'", type);
			return;
		}
		
		currentType = typeObj.getType();
	}
	
	public boolean passed() {
		return !errorDetected;
	}
	
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-07 12:59:01.572
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-07 12:59:01.573
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-07 12:59:02.628
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rs.ac.bg.etf.pp1;
import org.apache.log4j.Logger;

import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.Obj;
import rs.etf.pp1.symboltable.concepts.Struct;

public class SemanticPass extends VisitorAdaptor {

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

	private Obj thisProgram;

	private Struct currentType;
	
	private Struct boolType = Tab.find("bool").getType();

	private boolean mainHappened = false;

	private Obj currMethod;

	private Struct currRecord;

	public void report_error(String message, SyntaxNode info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.error(msg.toString());
	}

	public void report_info(String message, SyntaxNode info) {
		StringBuilder msg = new StringBuilder(message); 
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" in line ").append(line).append(".");
		log.info(msg.toString());
	}
	
	@Override
	public void visit(ProgramName programName) {
		thisProgram = Tab.insert(Obj.Prog, programName.getI1(), Tab.noType);
		Tab.openScope();
	}
	
	@Override
	public void visit(Program program) {		
		Tab.chainLocalSymbols(thisProgram);
		Tab.closeScope();
		
		if (!mainHappened)
			report_error("void main() method is not defined", program);
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------- GLOBAL_CONST_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(ConstDeclBool constDeclBool) {
		Obj tmp = Tab.find(constDeclBool.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclBool.getI1() + "'", constDeclBool);
		}
		else {
			if (boolType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclBool.getI1(), currentType);
				tmp.setAdr(constDeclBool.getB2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclBool.getI1() + "'", constDeclBool);
			}
		}
	}
	
	@Override
	public void visit(ConstDeclChar constDeclChar) {
		Obj tmp = Tab.find(constDeclChar.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclChar.getI1() + "'", constDeclChar);
		}
		else {
			if (Tab.charType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclChar.getI1(), currentType);
				tmp.setAdr(constDeclChar.getC2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclChar.getI1() + "'", constDeclChar);
			}	
		}
	}
	
	@Override
	public void visit(ConstDeclNumber constDeclNumber) {
		Obj tmp = Tab.find(constDeclNumber.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of constant '" + constDeclNumber.getI1() + "'", constDeclNumber);
		}
		else {
			if (Tab.intType.assignableTo(currentType)) {
				tmp = Tab.insert(Obj.Con, constDeclNumber.getI1(), currentType);
				tmp.setAdr(constDeclNumber.getN2());
			}
			else {
				report_error("Forbidden assignment for '" + constDeclNumber.getI1() + "'", constDeclNumber);
			}
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ------------------------------------------------------------------- GLOBAL_VAR_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(NormalVarDecl normalVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(normalVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(normalVarDecl.getI1());
		
		(currMethod == null && currRecord == null) ? tmp = Tab.find(normalVarDecl.getI1())
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, normalVarDecl.getI1(), currentType);
		}
		else {
			report_error("Multiple definitions of variable '" + normalVarDecl.getI1() + "'", normalVarDecl);
		}
	}
	
	@Override
	public void visit(ArrayVarDecl arrayVarDecl) {
		Obj tmp = null;
		if (currMethod == null && currRecord == null) tmp = Tab.find(arrayVarDecl.getI1());
		else tmp = Tab.currentScope().findSymbol(arrayVarDecl.getI1());
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(currRecord == null ? Obj.Var : Obj.Fld, arrayVarDecl.getI1(), new Struct(Struct.Array, currentType));
			if (currRecord != null) tmp.setLevel(2);
		}
		else {
			report_error("Multiple definitions of variable '" + arrayVarDecl.getI1() + "'", arrayVarDecl);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- METHOD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(MethodName methodName) {
		if (methodName.getI1().equalsIgnoreCase("main") && currentType == Tab.noType) mainHappened  = true;
		currMethod = Tab.insert(Obj.Meth, methodName.getI1(), currentType);
		Tab.openScope();
	}
	
	@Override
	public void visit(MethodRetVoid methodRetVoid) {
		currentType = Tab.noType;
	}
	
	@Override
	public void visit(MethDeclParams methDeclParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(MethDeclNoParams methDeclNoParams) {
		Tab.chainLocalSymbols(currMethod);
		Tab.closeScope();
		currMethod = null;
	}
	
	@Override
	public void visit(FormalParameter formalParameter) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameter);
		else tmp = Tab.currentScope().findSymbol(formalParameter.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main") && currMethod.getType() == Tab.noType) 
			report_error("Formal parameters in void main() are forbidden", formalParameter);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameter.getI2(), currentType);
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of formal parameter '" + formalParameter.getI2() + "'", formalParameter);
		}
	}
	
	@Override
	public void visit(FormalParameterArray formalParameterArray) {
		Obj tmp = null;
		if (currMethod == null) report_error("No current method for formal parameters. Error in class singleFormPars", formalParameterArray);
		else tmp = Tab.currentScope().findSymbol(formalParameterArray.getI2());
		
		if (currMethod.getName().equalsIgnoreCase("main")) report_error("Formal parameters in void main() are forbidden", formalParameterArray);
		
		if (tmp == Tab.noObj || tmp == null) {
			tmp = Tab.insert(Obj.Var, formalParameterArray.getI2(), new Struct(Struct.Array, currentType));
			currMethod.setLevel(currMethod.getLevel() + 1);
			tmp.setFpPos(1);
		}
		else {
			report_error("Multiple definitions of variable '" + formalParameterArray.getI2() + "'", formalParameterArray);
		}
	}
	
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	/* ----------------------------------------------------------------------- RECORD_DECLARATIONS ---------------------------------------------------------------- */
	/*--------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	
	@Override
	public void visit(RecordDeclName recordDeclName) {
		Obj tmp = Tab.find(recordDeclName.getI1());
		if (tmp != Tab.noObj) {
			report_error("Multiple definitions of record '" + recordDeclName.getI1() + "'", recordDeclName);
		}
		else {
			currRecord = new Struct(Struct.Class);
			tmp = Tab.insert(Obj.Type, recordDeclName.getI1(), currRecord);
			Tab.openScope();
		}
	}
	
	@Override
	public void visit(RecordDecl recordDecl) {
		Tab.chainLocalSymbols(currRecord);
		Tab.closeScope();
		currRecord = null;
	}
	
	@Override
	public void visit(Type type) {
		Obj typeObj = Tab.find(type.getI1());
		if (typeObj == Tab.noObj) {
			report_error("Type '" + type.getI1() + "' is not defined", type);
			currentType = Tab.noType;
			return;
		}
		
		if (typeObj.getKind() != Obj.Type) {
			report_error("Unallowed type '" + type.getI1() + "'", type);
			return;
		}
		
		currentType = typeObj.getType();
	}
	
	public boolean passed() {
		return !errorDetected;
	}
	
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-07 12:59:02.629
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-07 12:59:02.630
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 4 0 2022-02-07 13:18:11.345
!MESSAGE org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Internal error.
!STACK 0
java.util.concurrent.ExecutionException: org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Internal error.
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:396)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$13(LanguageServerWrapper.java:425)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Internal error.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponse(RemoteEndpoint.java:209)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:193)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$4(LanguageServerWrapper.java:260)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jface.text 4 0 2022-02-07 20:15:02.790
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.ClassCastException: class org.eclipse.jdt.internal.core.ClassFile cannot be cast to class org.eclipse.jdt.core.ICompilationUnit (org.eclipse.jdt.internal.core.ClassFile and org.eclipse.jdt.core.ICompilationUnit are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @36ae17ef)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypesInSourcePackage(NameLookup.java:1582)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:1453)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:1356)
	at org.eclipse.jdt.internal.core.NameLookup.findAllTypes(NameLookup.java:428)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:1426)
	at org.eclipse.jdt.internal.core.NameLookup.seekTypes(NameLookup.java:1356)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:944)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:746)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:572)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:551)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1105)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:662)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2022-02-07 20:17:51.762
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.ClassCastException
